<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT_QI // SINGULARITY_LOG</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* 极简主义科技配色 */
            --bg-deep: #050505;
            --ui-white: #e0e0e0;
            --ui-dim: #4a4a4a;
            
            --cyan: #00f0ff;    /* 能量/友军 */
            --red: #ff2a2a;     /* 威胁 */
            --purple: #bd00ff;  /* 激光 */
            --gold: #ffd700;    /* 炮塔 */
            
            --font-head: 'Orbitron', sans-serif;
            --font-body: 'Rajdhani', sans-serif;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            background-color: var(--bg-deep);
            color: var(--ui-white);
            font-family: var(--font-body);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: crosshair; /* 准星光标 */
        }

        /* 游戏层级 */
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #bg-layer { z-index: 0; opacity: 0.4; }
        #game-layer { z-index: 1; }
        #ui-layer { z-index: 10; position: absolute; width: 100%; height: 100%; pointer-events: none; }

        /* HUD 界面 */
        .hud-panel {
            position: absolute;
            pointer-events: auto; /* 允许点击UI */
            padding: 20px;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .top-left { top: 0; left: 0; }
        .top-center { 
            top: 20px; left: 50%; 
            transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center;
        }
        
        /* 状态数值 */
        .label { font-size: 10px; color: var(--ui-dim); letter-spacing: 2px; text-transform: uppercase; }
        .value { font-family: var(--font-head); font-size: 28px; letter-spacing: 2px; }
        .cyan { color: var(--cyan); text-shadow: 0 0 10px rgba(0, 240, 255, 0.5); }
        .red { color: var(--red); }

        /* 血条 */
        .hp-container {
            width: 400px; height: 4px;
            background: rgba(255,255,255,0.1);
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        .hp-fill {
            height: 100%; width: 100%;
            background: var(--red);
            box-shadow: 0 0 15px var(--red);
            transition: width 0.2s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* 升级菜单 (右侧悬浮) */
        #upgrade-menu {
            position: absolute;
            right: 0; top: 0; bottom: 0;
            width: 320px;
            background: linear-gradient(90deg, transparent 0%, rgba(10,10,10,0.95) 20%);
            border-left: 1px solid rgba(255,255,255,0.05);
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            pointer-events: auto;
        }

        h2 {
            font-family: var(--font-head);
            font-size: 16px;
            color: var(--ui-white);
            border-bottom: 1px solid var(--ui-dim);
            padding-bottom: 10px;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        /* 升级卡片 */
        .card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .card:hover:not(.disabled) {
            background: rgba(0, 240, 255, 0.05);
            border-color: var(--cyan);
            transform: translateX(-5px);
        }
        .card.disabled { opacity: 0.3; cursor: not-allowed; }

        .card-title { font-family: var(--font-head); font-size: 12px; color: var(--cyan); display: flex; justify-content: space-between; }
        .card-lvl { background: rgba(0,0,0,0.5); padding: 2px 5px; font-size: 9px; border-radius: 2px; color: #fff; }
        .card-desc { font-size: 11px; color: #888; margin-top: 5px; line-height: 1.4; }
        .card-cost { margin-top: 8px; font-size: 12px; color: var(--gold); font-weight: bold; text-align: right; }

        /* 屏幕震动 */
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        /* 启动界面 */
        #splash-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(5,5,5,0.98);
            z-index: 100; pointer-events: auto;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .btn-start {
            margin-top: 40px; padding: 15px 60px;
            background: transparent; color: var(--cyan);
            border: 1px solid var(--cyan);
            font-family: var(--font-head); font-size: 18px; letter-spacing: 4px;
            cursor: pointer; transition: 0.3s;
        }
        .btn-start:hover { background: var(--cyan); color: #000; box-shadow: 0 0 40px var(--cyan); }

        /* 飘字 */
        .floater { position: absolute; font-family: var(--font-head); font-weight: bold; pointer-events: none; animation: floatUp 0.8s forwards; font-size: 14px; text-shadow: 0 0 5px currentColor; }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-30px) scale(1.2); } }

    </style>
</head>
<body>
    
    <audio id="bgm" src="assets/bgm.mp3" loop autoplay></audio>

    <canvas id="bg-layer"></canvas>
    <canvas id="game-layer"></canvas>

    <div id="ui-layer">
        
        <div class="hud-panel top-left">
            <div class="label">ENERGY_RESERVE</div>
            <div class="value cyan"><span id="energy-display">0</span></div>
            <div class="label" style="margin-top:15px">THREAT_LEVEL</div>
            <div class="value"><span id="wave-display">1</span></div>
        </div>

        <div class="hud-panel top-center">
            <div class="label">CORE_INTEGRITY</div>
            <div class="hp-container">
                <div class="hp-fill" id="hp-bar"></div>
            </div>
            <div class="label" style="margin-top:5px; text-align:center;"><span id="hp-text">100</span>%</div>
        </div>

        <div id="upgrade-menu">
            <h2>SYSTEM CONFIG</h2>

            <div class="card" id="card-gun" onclick="Game.upgrade('gun')">
                <div class="card-title">
                    PRIMARY_LASER
                    <span class="card-lvl">LV <span id="lvl-gun">1</span>/5</span>
                </div>
                <div class="card-desc" id="desc-gun">单发速射模式</div>
                <div class="card-cost" id="cost-gun">50</div>
            </div>

            <div class="card" id="card-turret" onclick="Game.upgrade('turret')">
                <div class="card-title">
                    ORBITAL_DRONE
                    <span class="card-lvl">LV <span id="lvl-turret">0</span>/5</span>
                </div>
                <div class="card-desc" id="desc-turret">部署浮游攻击终端</div>
                <div class="card-cost" id="cost-turret">100</div>
            </div>

            <div class="card" id="card-rate" onclick="Game.upgrade('rate')">
                <div class="card-title">
                    DATA_MINING
                    <span class="card-lvl">INF</span>
                </div>
                <div class="card-desc">自动生产: +1.0/s. 点击增益: +15</div>
                <div class="card-cost" id="cost-rate">30</div>
            </div>

            <div class="card" id="card-heal" onclick="Game.upgrade('heal')">
                <div class="card-title">
                    AUTO_REPAIR
                </div>
                <div class="card-desc">修复 30 点核心生命值</div>
                <div class="card-cost" id="cost-heal">50</div>
            </div>
        </div>
    </div>

    <div id="splash-screen">
        <h1 style="font-family:var(--font-head); font-size:48px; color:#fff; letter-spacing:5px; text-shadow:0 0 30px var(--cyan);">PROJECT_QI</h1>
        <p style="color:var(--cyan); letter-spacing:3px; font-size:12px;">SINGULARITY DEFENSE PROTOCOL</p>
        <p style="color:#999; font-size:10px; margin-top:10px;">(点击屏幕以初始化神经连接)</p>
        <button class="btn-start" onclick="Game.init()">INITIALIZE</button>
    </div>

    <script>
        const AudioSys = {
            ctx: null,
            bgm: null,
            isBgmPlaying: false,

            init() { 
                this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                this.bgm = document.getElementById('bgm');
            },

            startBGM() {
                if(!this.isBgmPlaying && this.bgm) {
                    this.bgm.volume = 0.4; 
                    this.bgm.play().then(() => {
                        this.isBgmPlaying = true;
                    }).catch(e => {
                        console.log("BGM 自动播放被拦截，等待交互");
                    });
                }
            },

            play(type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if (type === 'laser') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(800, t);
                    osc.frequency.exponentialRampToValueAtTime(100, t+0.15);
                    gain.gain.value = 0.03; 
                } else if (type === 'turret') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(1500, t);
                    osc.frequency.exponentialRampToValueAtTime(500, t+0.05);
                    gain.gain.value = 0.01;
                } else if (type === 'hit') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100, t);
                    osc.frequency.linearRampToValueAtTime(0, t+0.1);
                    gain.gain.value = 0.08;
                } else if (type === 'collect') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, t);
                    osc.frequency.linearRampToValueAtTime(1800, t+0.1);
                    gain.gain.value = 0.03;
                }

                osc.connect(gain).connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.2);
            }
        };

        const Game = {
            bgCanvas: document.getElementById('bg-layer'),
            canvas: document.getElementById('game-layer'),
            bgCtx: null, ctx: null,
            w: 0, h: 0, frame: 0, running: false,

            // 数据
            energy: 0,
            hp: 100, maxHp: 100,
            wave: 1,

            // 升级配置
            upgrades: {
                gun: { level: 1, max: 5, cost: 50, name: "主炮" },
                turret: { level: 0, max: 5, cost: 100, name: "浮游炮" },
                rate: { level: 1, cost: 30, name: "采集" },
                heal: { cost: 50, name: "修复" }
            },

            // 艺术资产 (修改点 2: 声明图片对象)
            assets: {
                core: new Image(),
                enemy: new Image(),
                orb: new Image()
            },

            // 实体
            orbs: [],       
            enemies: [],    
            bullets: [],    
            particles: [],  
            
            lastFire: 0,
            autoEnergyRate: 1, 

            init() {
                AudioSys.init();
                
                // 修改点 3: 加载 assets 文件夹里的图片
                this.assets.core.src = 'assets/core.svg';
                this.assets.enemy.src = 'assets/enemy.svg';
                this.assets.orb.src = 'assets/orb.svg';

                document.getElementById('splash-screen').style.opacity = 0;
                setTimeout(() => document.getElementById('splash-screen').remove(), 500);

                this.bgCtx = this.bgCanvas.getContext('2d');
                this.ctx = this.canvas.getContext('2d');
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.canvas.addEventListener('mousedown', e => this.onClick(e));
                this.canvas.addEventListener('touchstart', e => this.onClick(e.touches[0]));

                this.running = true;
                this.loop();
                this.updateUI();
                AudioSys.startBGM(); 
            },

            resize() {
                this.w = window.innerWidth;
                this.h = window.innerHeight;
                this.bgCanvas.width = this.canvas.width = this.w;
                this.bgCanvas.height = this.canvas.height = this.h;
            },

            onClick(e) {
                const mx = e.clientX, my = e.clientY;
                for(let i = this.orbs.length-1; i>=0; i--) {
                    const o = this.orbs[i];
                    const dist = Math.hypot(o.x - mx, o.y - my);
                    if(dist < o.r + 30) { 
                        const gain = 15 + (this.upgrades.rate.level * 5); 
                        this.energy += gain;
                        this.spawnText(o.x, o.y, `+${gain}`, '#00f0ff');
                        this.spawnExplosion(o.x, o.y, 10, '#00f0ff');
                        this.orbs.splice(i, 1);
                        AudioSys.play('collect');
                        this.updateUI();
                        return;
                    }
                }
            },

            upgrade(type) {
                const u = this.upgrades[type];
                if(type === 'heal') {
                    if(this.energy >= u.cost && this.hp < this.maxHp) {
                        this.energy -= u.cost;
                        this.hp = Math.min(this.maxHp, this.hp + 30);
                        u.cost = Math.floor(u.cost * 1.5); 
                        this.spawnText(this.w/2, this.h/2, "REPAIRED", "#00ff00");
                        this.updateUI();
                    }
                    return;
                }
                if(this.energy >= u.cost && (u.max ? u.level < u.max : true)) {
                    this.energy -= u.cost;
                    u.level++;
                    u.cost = Math.floor(u.cost * 1.5);
                    if(type === 'rate') this.autoEnergyRate = 1 + u.level * 0.5;
                    this.updateUI();
                }
            },

            loop() {
                if(!this.running) return;
                this.frame++;
                this.drawBg();
                this.updateLogic();
                this.drawGame();
                requestAnimationFrame(() => this.loop());
            },
            
            drawBg() {
                const ctx = this.bgCtx;
                ctx.clearRect(0,0,this.w,this.h);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                const cx = this.w/2, cy = this.h/2;
                const time = this.frame * 0.005;
                const spacing = 50;
                ctx.beginPath();
                for(let x=0; x<=this.w; x+=spacing) {
                    ctx.moveTo(x, 0); 
                    const dist = Math.abs(x - cx);
                    const offset = Math.sin(time + dist*0.01) * 10;
                    ctx.lineTo(cx + (x-cx)*0.1, cy);
                }
                for(let y=0; y<=this.h; y+=spacing) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(cx, cy + (y-cy)*0.1);
                }
                ctx.stroke();
            },

            updateLogic() {
                const cx = this.w/2, cy = this.h/2;
                
                if(this.frame % 60 === 0) {
                    this.energy += this.autoEnergyRate;
                    this.updateUI();
                }

                const rate = Math.max(120, 180 - this.upgrades.rate.level * 5); 
                if(this.frame % rate === 0) {
                    const pad = 100;
                    this.orbs.push({
                        x: pad + Math.random()*(this.w - pad*2),
                        y: pad + Math.random()*(this.h - pad*2),
                        vx: (Math.random()-0.5)*0.5, vy: (Math.random()-0.5)*0.5,
                        r: 0, maxR: 20, life: 400
                    });
                }

                const enemyRate = Math.max(60, 240 - this.wave * 10); 
                if(this.frame % enemyRate === 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.max(this.w, this.h) / 1.5;
                    const ex = cx + Math.cos(angle) * r;
                    const ey = cy + Math.sin(angle) * r;
                    const hp = 10 + this.wave * 15; 
                    const spd = 0.3 + this.wave * 0.04;
                    this.enemies.push({ x: ex, y: ey, hp: hp, maxHp: hp, speed: spd, radius: 15 });
                }

                if(this.frame % 1500 === 0) { 
                    this.wave++;
                    this.spawnText(cx, cy - 100, `WARNING: WAVE ${this.wave}`, '#ff2a2a');
                }

                const gunLvl = this.upgrades.gun.level;
                const fireCd = Math.max(10, 80 - gunLvl * 12); 
                if(this.frame - this.lastFire > fireCd) {
                    const target = this.getNearestEnemy(cx, cy);
                    if(target) {
                        this.lastFire = this.frame;
                        AudioSys.play('laser');
                        const angle = Math.atan2(target.y - cy, target.x - cx);
                        const dmg = 5 + gunLvl * 4; 
                        const spd = 8;
                        let shots = [];
                        if(gunLvl === 1) shots = [0];
                        else if(gunLvl === 2) shots = [0]; 
                        else if(gunLvl === 3) shots = [-0.1, 0.1]; 
                        else if(gunLvl === 4) shots = [-0.15, 0.15]; 
                        else if(gunLvl >= 5) shots = [-0.2, 0, 0.2]; 
                        shots.forEach(offset => {
                            this.bullets.push({
                                x: cx, y: cy, vx: Math.cos(angle + offset) * spd, vy: Math.sin(angle + offset) * spd,
                                dmg: dmg, size: gunLvl >= 4 ? 5 : 3, color: '#bd00ff', life: 100
                            });
                        });
                    }
                }

                const turretCount = this.upgrades.turret.level;
                const tRadius = 70;
                if(turretCount > 0 && this.frame % 35 === 0) { 
                    for(let i=0; i<turretCount; i++) {
                        const tAngle = (this.frame * 0.02) + (i * (Math.PI*2/turretCount));
                        const tx = cx + Math.cos(tAngle)*tRadius;
                        const ty = cy + Math.sin(tAngle)*tRadius;
                        const target = this.getNearestEnemy(tx, ty);
                        if(target) {
                            AudioSys.play('turret');
                            const aim = Math.atan2(target.y - ty, target.x - tx);
                            this.bullets.push({
                                x: tx, y: ty, vx: Math.cos(aim) * 6, vy: Math.sin(aim) * 6,
                                dmg: 5, size: 2, color: '#ffd700', life: 60
                            });
                        }
                    }
                }

                this.orbs.forEach(o => {
                    if(o.r < o.maxR) o.r += 0.5;
                    o.x += o.vx; o.y += o.vy; o.life--;
                });
                this.orbs = this.orbs.filter(o => o.life > 0);

                this.enemies.forEach(e => {
                    const angle = Math.atan2(cy - e.y, cx - e.x);
                    e.x += Math.cos(angle) * e.speed;
                    e.y += Math.sin(angle) * e.speed;
                    if(Math.hypot(cx - e.x, cy - e.y) < 40) {
                        e.dead = true;
                        this.hp -= 10;
                        AudioSys.play('hit');
                        document.body.classList.add('shake'); 
                        setTimeout(()=>document.body.classList.remove('shake'), 500);
                        this.spawnExplosion(e.x, e.y, 20, '#ff2a2a');
                        this.updateUI();
                        if(this.hp <= 0) this.gameOver();
                    }
                });

                this.bullets.forEach(b => {
                    b.x += b.vx; b.y += b.vy; b.life--;
                    for(let e of this.enemies) {
                        if(Math.hypot(b.x - e.x, b.y - e.y) < e.radius + b.size + 5) {
                            b.life = 0;
                            e.hp -= b.dmg;
                            e.hitFlash = 5; 
                            this.spawnExplosion(b.x, b.y, 3, b.color);
                            if(e.hp <= 0) {
                                e.dead = true;
                                this.spawnExplosion(e.x, e.y, 15, '#ff2a2a');
                            }
                            break;
                        }
                    }
                });

                this.particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy; p.life--; p.alpha -= 0.03;
                });

                this.enemies = this.enemies.filter(e => !e.dead);
                this.bullets = this.bullets.filter(b => b.life > 0);
                this.particles = this.particles.filter(p => p.life > 0);
            },

            drawGame() {
                const ctx = this.ctx;
                const cx = this.w/2, cy = this.h/2;
                ctx.clearRect(0,0,this.w,this.h);

                // 1. 绘制核心 Qi (使用图片)
                // 修改点 4: 使用 drawImage 绘制 core.svg
                const coreSize = 100;
                if (this.assets.core.complete) {
                    ctx.save();
                    ctx.translate(cx, cy);
                    // 核心自转效果
                    ctx.rotate(this.frame * 0.005);
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00f0ff';
                    ctx.drawImage(this.assets.core, -coreSize/2, -coreSize/2, coreSize, coreSize);
                    ctx.restore();
                }

                // 2. 绘制浮游炮塔
                const tCount = this.upgrades.turret.level;
                const tRadius = 70;
                ctx.fillStyle = '#ffd700';
                for(let i=0; i<tCount; i++) {
                    const angle = (this.frame * 0.02) + (i * (Math.PI*2/tCount));
                    const tx = cx + Math.cos(angle)*tRadius;
                    const ty = cy + Math.sin(angle)*tRadius;
                    ctx.save();
                    ctx.translate(tx, ty);
                    ctx.rotate(angle + Math.PI/2); 
                    ctx.beginPath();
                    ctx.moveTo(0, -8); ctx.lineTo(-6, 6); ctx.lineTo(6, 6);
                    ctx.fill();
                    ctx.restore();
                }

                // 3. 绘制资源 Orbs (使用图片)
                // 修改点 5: 使用 drawImage 绘制 orb.svg
                this.orbs.forEach(o => {
                    if (this.assets.orb.complete) {
                        ctx.globalAlpha = o.life < 50 ? o.life/50 : 1;
                        // 让图片大小随动画变化
                        const s = o.r * 2.5; 
                        ctx.drawImage(this.assets.orb, o.x - s/2, o.y - s/2, s, s);
                        ctx.globalAlpha = 1;
                    }
                });

                // 4. 绘制敌人 (使用图片)
                // 修改点 6: 使用 drawImage 绘制 enemy.svg
                this.enemies.forEach(e => {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    const angle = Math.atan2(cy - e.y, cx - e.x);
                    // 修正 svg 的朝向，+90度
                    ctx.rotate(angle + Math.PI/2); 
                    
                    if(e.hitFlash > 0) {
                        ctx.globalCompositeOperation = 'source-atop';
                        ctx.fillStyle = 'white';
                        ctx.beginPath(); ctx.arc(0,0,e.radius,0,Math.PI*2); ctx.fill();
                        e.hitFlash--;
                    } else if (this.assets.enemy.complete) {
                        const s = e.radius * 2.5;
                        ctx.drawImage(this.assets.enemy, -s/2, -s/2, s, s);
                    }
                    
                    // 血条
                    if(e.hp < e.maxHp) {
                        ctx.rotate(-(angle + Math.PI/2)); // 保持血条水平
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(-e.radius, -e.radius-8, e.radius*2 * (e.hp/e.maxHp), 2);
                    }
                    ctx.restore();
                });

                // 5. 子弹
                this.bullets.forEach(b => {
                    ctx.fillStyle = b.color;
                    ctx.shadowBlur = 5; ctx.shadowColor = b.color;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = b.size;
                    ctx.beginPath();
                    ctx.moveTo(b.x, b.y);
                    ctx.lineTo(b.x - b.vx*2, b.y - b.vy*2);
                    ctx.stroke();
                });

                // 6. 粒子
                this.particles.forEach(p => {
                    ctx.globalAlpha = Math.max(0, p.alpha);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 3, 3);
                    ctx.globalAlpha = 1;
                });
            },

            getNearestEnemy(x, y) {
                let nearest = null, min = Infinity;
                for(let e of this.enemies) {
                    const d = Math.hypot(e.x - x, e.y - y);
                    if(d < min) { min = d; nearest = e; }
                }
                return nearest;
            },

            spawnExplosion(x, y, count, color) {
                for(let i=0; i<count; i++) {
                    this.particles.push({
                        x, y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8,
                        life: 30, alpha: 1, color: color
                    });
                }
            },

            spawnText(x, y, text, color) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.left = x + 'px'; el.style.top = y + 'px';
                el.style.color = color;
                el.innerText = text;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 800);
            },

            updateUI() {
                document.getElementById('energy-display').innerText = Math.floor(this.energy);
                document.getElementById('wave-display').innerText = this.wave;
                document.getElementById('hp-bar').style.width = (this.hp/this.maxHp)*100 + '%';
                document.getElementById('hp-text').innerText = Math.ceil(this.hp);

                this.updateCard('gun', '主炮');
                this.updateCard('turret', '浮游炮');
                this.updateCard('rate', '采集');
                this.updateCard('heal', '修复');
            },

            updateCard(type, name) {
                const u = this.upgrades[type];
                const card = document.getElementById('card-'+type);
                document.getElementById('cost-'+type).innerText = u.cost;
                if(u.max) document.getElementById('lvl-'+type).innerText = u.level;

                let desc = "";
                if(type === 'gun') {
                    if(u.level===1) desc="单发速射 (初始火力)";
                    else if(u.level===2) desc="射速提升 (LVL 2)";
                    else if(u.level===3) desc="双发平行 (LVL 3)";
                    else if(u.level===4) desc="大口径双发 (LVL 4)";
                    else desc="三发广域散射 (MAX LVL)";
                } else if(type === 'turret') {
                    desc = `当前部署: ${u.level} 机 (每级增加一台)`;
                } else if(type === 'rate') {
                    desc = `自动产出: ${this.autoEnergyRate.toFixed(1)}/秒. 点击增益: +${15 + u.level * 5}`;
                } else {
                    desc = `修复 30 点生命值。下次成本: ${Math.floor(u.cost * 1.5)}`;
                }
                if(type !== 'heal' && type !== 'rate') document.getElementById('desc-'+type).innerText = desc;
                if(type === 'rate') document.getElementById('desc-'+type).innerHTML = desc;

                if(this.energy < u.cost || (u.max && u.level >= u.max)) {
                    card.classList.add('disabled');
                } else {
                    card.classList.remove('disabled');
                }
            },

            gameOver() {
                this.running = false;
                alert(`CORE DESTROYED // 核心损毁\nWAVES SURVIVED: ${this.wave}`);
                location.reload();
            }
        };
    </script>
</body>
</html>
